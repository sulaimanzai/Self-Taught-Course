<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Module 7: Post-Ex UDRL & Aggressor Integration - Crystal-Loaders Course</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x1F48E;</text></svg>">
<link rel="stylesheet" href="../../../assets/course.css">
<style>:root{--accent:#f43f5e;--accent2:#fb923c;--gradient:linear-gradient(135deg,#f43f5e,#fb923c)}</style>
</head>
<body>

<button class="hamburger" aria-label="Toggle navigation">&#9776;</button>

<nav>
<div class="logo">
<h2>Crystal-Loaders</h2>
<span>PIC Reflective Loaders</span>
</div>
<a class="home-link" href="../CrystalLoaders_index.html">&larr; Course Home</a>
<a class="mod-link" href="module1.html"><span class="diff d1">1</span> The Loader Problem</a>
<a class="mod-link" href="module2.html"><span class="diff d1">2</span> Crystal Palace</a>
<a class="mod-link" href="module3.html"><span class="diff d2">3</span> LibTCG</a>
<a class="mod-link" href="module4.html"><span class="diff d2">4</span> LibGate Syscalls</a>
<a class="mod-link" href="module5.html"><span class="diff d2">5</span> UDRL Walkthrough</a>
<a class="mod-link" href="module6.html"><span class="diff d3">6</span> Beacon User Data</a>
<a class="mod-link active" href="module7.html"><span class="diff d3">7</span> Post-Ex &amp; Aggressor</a>
<a class="mod-link" href="module8.html"><span class="diff d3">8</span> Extending Loaders</a>
</nav>

<main>
<span class="diff-badge hard">Difficulty: Advanced</span>
<h1>Module 7: Post-Ex UDRL &amp; Aggressor Integration</h1>
<p class="subtitle">The postex loader, $GMH/$GPA patching, string-based DFR, Aggressor hooks, and the complete build pipeline from C source to deployed Beacon.</p>

<div class="card highlight">
<h4>Module Objective</h4>
<p>Understand how Cobalt Strike's post-exploitation DLLs are loaded by a separate, simplified UDRL. You will learn how the postex loader differs from the Beacon UDRL, how it receives API resolution capabilities from its parent Beacon via <code>$GMH</code>/<code>$GPA</code> patching, and how the Aggressor script ties the entire Crystal-Loaders system together. By the end of this module you will be able to trace a complete payload from C source through Crystal Palace to a running Beacon on target.</p>
</div>

<!-- ============================================================ -->
<h2>1. What Is Post-Ex?</h2>

<p>Cobalt Strike's post-exploitation capabilities &mdash; <code>mimikatz</code>, <code>screenshot</code>, <code>keylogger</code>, <code>port scan</code>, <code>hashdump</code>, <code>net</code> commands, and many others &mdash; are implemented as standalone DLLs. When an operator runs one of these commands through the Beacon console, Cobalt Strike compiles or selects the appropriate postex DLL and sends it to the running Beacon for execution.</p>

<p>These postex DLLs need their own loader. The initial Beacon UDRL (covered in Modules 5 and 6) loads the Beacon implant itself, but every subsequent postex capability that arrives as a DLL also needs to be reflectively loaded into memory. Cobalt Strike provides a dedicated hook for this purpose: <strong>POSTEX_RDLL_GENERATE</strong>.</p>

<div class="card">
<h4>Why a Separate Loader?</h4>
<p>The postex loader is architecturally simpler than the Beacon UDRL because it operates in a fundamentally different context. The Beacon is already running, API resolution is already solved, syscall stubs are already resolved, and the BUD (Beacon User Data) is already populated. The postex loader does not need to bootstrap any of this infrastructure &mdash; it inherits resolution capabilities from its parent Beacon via function pointer patching.</p>
</div>

<div class="card warn">
<h4>Key Distinction</h4>
<p>The <code>POSTEX_RDLL_GENERATE</code> Aggressor hook allows operators to replace the default postex loader with a custom one &mdash; just as <code>BEACON_RDLL_GENERATE</code> allows replacing the Beacon's own loader. Crystal-Loaders provides both: a full-featured Beacon UDRL and a streamlined postex UDRL, each with its own spec file and C source.</p>
</div>

<!-- ============================================================ -->
<h2>2. Key Differences from the Beacon UDRL</h2>

<p>The postex loader shares the same Crystal Palace build system and LibTCG PE loading primitives as the Beacon UDRL, but it strips away everything that the parent Beacon already provides. The following table highlights every architectural difference:</p>

<table>
<thead>
<tr><th>Aspect</th><th>Beacon UDRL (loader.c)</th><th>Post-Ex UDRL (loader.c)</th></tr>
</thead>
<tbody>
<tr><td><strong>Includes</strong></td><td><code>beacon.h</code>, <code>gate.h</code>, <code>tcg.h</code></td><td><code>tcg.h</code> only</td></tr>
<tr><td><strong>Syscall resolution</strong></td><td>Full <code>SYSCALL_API</code> via LibGate</td><td>None needed</td></tr>
<tr><td><strong>DFR method</strong></td><td><code>ror13</code> (hash-based)</td><td><code>strings</code> (ASCII name-based)</td></tr>
<tr><td><strong>API resolution</strong></td><td>PEB walking via <code>findModuleByHash</code></td><td><code>$GMH</code>/<code>$GPA</code> from parent Beacon</td></tr>
<tr><td><strong>BUD population</strong></td><td>Full <code>BEACON_USER_DATA</code></td><td>None</td></tr>
<tr><td><strong>Entry params</strong></td><td><code>go()</code> takes no args</td><td><code>go(void* loaderArguments)</code></td></tr>
<tr><td><strong>DllMain calls</strong></td><td>3 (BEACON_USER_DATA, ATTACH, START)</td><td>2 (ATTACH, START)</td></tr>
<tr><td><strong>Memory tracking</strong></td><td><code>ALLOCATED_MEMORY_REGION</code></td><td><code>RDATA_SECTION</code></td></tr>
<tr><td><strong>Section masking</strong></td><td>Full section tracking</td><td><code>.rdata</code> capture only</td></tr>
</tbody>
</table>

<p>The most striking reduction is in dependencies. The Beacon UDRL includes <code>beacon.h</code> (for BUD structures), <code>gate.h</code> (for LibGate syscalls), and <code>tcg.h</code> (for PE loading). The postex loader only needs <code>tcg.h</code> because it does not resolve syscalls and does not populate BUD. It is purely a PE loading engine with inherited API resolution.</p>

<div class="card green">
<h4>Why This Matters for Evasion</h4>
<p>A smaller loader means a smaller PIC blob, which means less code in memory to scan, fewer function calls to trace, and a reduced detection surface. The postex loader also avoids touching the PEB directly (it uses patched-in function pointers instead of PEB walking), which sidesteps PEB access monitoring that some EDR products implement.</p>
</div>

<!-- ============================================================ -->
<h2>3. The $GMH / $GPA Patching Mechanism</h2>

<p>The central design question for the postex loader is: how does it resolve Windows API functions without PEB walking and without LibGate? The answer is <strong>function pointer patching</strong>. The parent Beacon already has resolved addresses for <code>GetModuleHandleA</code> and <code>GetProcAddress</code>. Crystal Palace writes those addresses directly into the postex loader's code before it executes.</p>

<h3>Global Function Pointers in .text</h3>

<p>The postex <code>loader.c</code> declares two global function pointers with an unusual attribute &mdash; they are placed in the <code>.text</code> section instead of <code>.data</code>:</p>

<pre><code><span class="lang-tag">C (postex/loader.c)</span>// Global function pointers stored in .text section
__typeof__(GetModuleHandleA) * pGetModuleHandle __attribute__((section(".text")));
__typeof__(GetProcAddress)   * pGetProcAddress  __attribute__((section(".text")));</code></pre>

<p>Placing them in <code>.text</code> is deliberate. After Crystal Palace transforms the COFF object into PIC, the <code>.text</code> section becomes the executable code body. By placing the pointers here, they become part of the PIC blob itself &mdash; directly addressable via RIP-relative instructions. If they were in <code>.data</code>, Crystal Palace would need to handle an additional data section and relocations.</p>

<h3>The patch Directive</h3>

<p>The postex spec file uses Crystal Palace's <code>patch</code> directive to write values into these symbol locations:</p>

<pre><code><span class="lang-tag">loader.spec (postex)</span>name     "Beacon Postex Loader"
describe "PIC loader for Cobalt Strike's postex DLLs"
author   "Daniel Duggan (@_RastaMouse)"

x64:
    load "bin/loader.x64.o"
        make pic +gofirst +optimize +disco
        dfr "resolve" "strings"
        patch "pGetModuleHandle" $GMH
        patch "pGetProcAddress"  $GPA
        mergelib "../libtcg.x64.zip"

    generate $KEY 128
    push $DLL
        xor $KEY
        preplen
        link "dll"
    push $KEY
        preplen
        link "key"
    export</code></pre>

<p>The <code>$GMH</code> and <code>$GPA</code> variables are <strong>not defined in the spec itself</strong>. They are provided externally by the Aggressor script at runtime, which receives them from Cobalt Strike as parameters to the <code>POSTEX_RDLL_GENERATE</code> hook. Crystal Palace resolves the symbol names <code>"pGetModuleHandle"</code> and <code>"pGetProcAddress"</code> in the COFF object's symbol table and overwrites those locations with the 8-byte addresses provided by <code>$GMH</code> and <code>$GPA</code>.</p>

<div class="diagram">
<h4 style="color:var(--accent);text-align:center;margin-bottom:15px;">$GMH / $GPA Patching Flow</h4>
<div class="flow">
<div class="box">Parent Beacon<br><small>has resolved GMH/GPA</small></div>
<div class="arrow">&rarr;</div>
<div class="box">CS Engine<br><small>passes to Aggressor hook</small></div>
<div class="arrow">&rarr;</div>
<div class="box hl">Crystal Palace<br><small>patch directive</small></div>
<div class="arrow">&rarr;</div>
<div class="box g">PIC Blob<br><small>pointers baked in .text</small></div>
</div>
</div>

<div class="card">
<h4>Comparing Spec Directives: Beacon vs Post-Ex</h4>
<table>
<thead>
<tr><th>Directive</th><th>Beacon Spec</th><th>Post-Ex Spec</th></tr>
</thead>
<tbody>
<tr><td><code>dfr</code></td><td><code>"resolve" "ror13"</code></td><td><code>"resolve" "strings"</code></td></tr>
<tr><td><code>patch</code></td><td>Not used</td><td><code>patch "pGetModuleHandle" $GMH</code><br><code>patch "pGetProcAddress" $GPA</code></td></tr>
<tr><td><code>mergelib</code></td><td>LibGate + LibTCG</td><td>LibTCG only</td></tr>
</tbody>
</table>
</div>

<!-- ============================================================ -->
<h2>4. The Post-Ex resolve() Function</h2>

<p>Because the postex spec uses <code>dfr "resolve" "strings"</code>, Crystal Palace rewrites all <code>__imp_MODULE$Function</code> references to call <code>resolve()</code> with ASCII string arguments instead of ROR13 hashes. The postex <code>resolve()</code> function is correspondingly different from the Beacon UDRL's version:</p>

<pre><code><span class="lang-tag">C (postex/loader.c)</span>char * resolve(char * module, char * function)
{
    HANDLE hModule = pGetModuleHandle(module);

    if (hModule == NULL)
        hModule = LoadLibraryA(module);

    return pGetProcAddress(hModule, function);
}</code></pre>

<p>This function is deceptively simple, but every line is significant:</p>

<div class="card">
<h4>Line-by-Line Analysis</h4>
<table>
<thead>
<tr><th>Line</th><th>What It Does</th></tr>
</thead>
<tbody>
<tr><td><code>pGetModuleHandle(module)</code></td><td>Attempts to get a handle to the module using the patched <code>$GMH</code> pointer. This succeeds if the DLL is already loaded in the process (e.g., <code>kernel32.dll</code>, <code>ntdll.dll</code>).</td></tr>
<tr><td><code>if (hModule == NULL)</code></td><td>If the module is not already loaded, the function needs to load it first. This happens when postex DLLs import from less common DLLs.</td></tr>
<tr><td><code>LoadLibraryA(module)</code></td><td>Calls <code>LoadLibraryA</code> directly to load the module. This is available as a plain function call because it comes from <code>&lt;windows.h&gt;</code> and is not DFR-decorated.</td></tr>
<tr><td><code>pGetProcAddress(hModule, function)</code></td><td>Finally resolves the target function from the (now loaded) module and returns its address.</td></tr>
</tbody>
</table>
</div>

<h3>Comparison with Beacon UDRL resolve()</h3>

<div class="versus">
<div>
<h5 style="color:var(--accent)">Beacon UDRL resolve()</h5>
<ul>
<li>Takes two <strong>DWORD hashes</strong> (ROR13)</li>
<li>Walks the PEB's <code>InMemoryOrderModuleList</code></li>
<li>Hashes each module name, compares against <code>moduleHash</code></li>
<li>Walks export table, hashes each function name</li>
<li>No dependency on any external function pointers</li>
<li>Fully self-contained &mdash; works from a cold start</li>
</ul>
</div>
<div>
<h5 style="color:var(--accent2)">Post-Ex resolve()</h5>
<ul>
<li>Takes two <strong>ASCII strings</strong> (module name, function name)</li>
<li>Calls <code>pGetModuleHandle</code> (patched <code>$GMH</code>)</li>
<li>Falls back to <code>LoadLibraryA</code> (direct call, not DFR-decorated) if module not loaded</li>
<li>Calls <code>pGetProcAddress</code> (patched <code>$GPA</code>)</li>
<li>Depends on parent Beacon's function pointers</li>
<li>Cannot operate independently &mdash; requires a running Beacon</li>
</ul>
</div>
</div>

<!-- ============================================================ -->
<h2>5. RDATA_SECTION Tracking</h2>

<p>The Beacon UDRL tracks all allocated memory regions via <code>ALLOCATED_MEMORY_REGION</code> structures in the BUD. The postex loader uses a simpler tracking mechanism: it captures only the <code>.rdata</code> section's location and size.</p>

<pre><code><span class="lang-tag">C (postex/loader.c)</span>typedef struct {
    char * start;      // Start address of .rdata
    DWORD  length;     // Size of .rdata
    DWORD  offset;     // Offset of IAT within .rdata
} RDATA_SECTION;</code></pre>

<h3>Why Track .rdata?</h3>

<p>Long-running postex DLLs &mdash; such as the <strong>keylogger</strong>, <strong>screenshot</strong> capture loop, or <strong>port scanner</strong> &mdash; persist in memory for extended periods. While they are idle between operations, their memory is vulnerable to scanning. The <code>.rdata</code> section is the highest-value forensic target because it contains:</p>

<div class="card warn">
<h4>What Lives in .rdata</h4>
<ul>
<li><strong>The Import Address Table (IAT)</strong> &mdash; An array of resolved function pointers to APIs in <code>ntdll.dll</code>, <code>kernel32.dll</code>, and other system DLLs. These pointers are recognizable patterns: consecutive addresses within the same DLL's export range.</li>
<li><strong>String literals</strong> &mdash; Read-only strings used by the postex DLL (error messages, format strings, registry key paths).</li>
<li><strong>Virtual function tables</strong> &mdash; For C++ postex DLLs, vtable pointers reside in <code>.rdata</code>.</li>
<li><strong>Constant data</strong> &mdash; Any <code>const</code> global data the compiler places in read-only sections.</li>
</ul>
</div>

<p>By passing the <code>RDATA_SECTION</code> structure to the postex DLL via <code>DllMain(DLL_PROCESS_ATTACH, &amp;rdata)</code>, the DLL can XOR-encrypt or zero its own <code>.rdata</code> section while idle. When it needs to run again, it decrypts the section, performs its operation, and re-encrypts. This pattern is the postex equivalent of the sleep mask technique used by the Beacon itself.</p>

<div class="diagram">
<h4 style="color:var(--accent);text-align:center;margin-bottom:15px;">RDATA Obfuscation Lifecycle</h4>
<div class="flow">
<div class="box">Postex DLL loaded<br><small>.rdata populated with IAT</small></div>
<div class="arrow">&rarr;</div>
<div class="box">Operation completes<br><small>keylogger cycle done</small></div>
<div class="arrow">&rarr;</div>
<div class="box hl">XOR encrypt .rdata<br><small>using RDATA_SECTION info</small></div>
<div class="arrow">&rarr;</div>
<div class="box g">Idle (safe)<br><small>no readable IAT in memory</small></div>
</div>
</div>

<!-- ============================================================ -->
<h2>6. The Post-Ex go() Function</h2>

<p>The postex <code>go()</code> function is the entry point of the PIC blob. Crystal Palace places it at byte offset 0 via the <code>+gofirst</code> flag. Unlike the Beacon UDRL's <code>go()</code> (which takes no arguments), the postex version receives a <code>loaderArguments</code> pointer from the parent Beacon:</p>

<pre><code><span class="lang-tag">C (postex/loader.c)</span>void go(void * loaderArguments)
{
    RESOURCE * dll = (RESOURCE *)GETRESOURCE(_DLL_);
    RESOURCE * key = (RESOURCE *)GETRESOURCE(_KEY_);

    // XOR unmask the encrypted postex DLL
    char * src = KERNEL32$VirtualAlloc(
        NULL, dll->length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    for (DWORD i = 0; i < dll->length; i++)
        src[i] = dll->value[i] ^ key->value[i % key->length];

    // Parse the decrypted PE
    DLLDATA data;
    ParseDLL(src, &data);

    // Allocate and load sections
    IMPORTFUNCS funcs;
    DWORD size = SizeOfDLL(&data);
    char * dst = KERNEL32$VirtualAlloc(
        NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    LoadDLL(&data, dst);
    ProcessImports(&funcs, &data, dst);

    // Fix permissions and capture .rdata info
    RDATA_SECTION rdata;
    FixSectionPermissions(&data, dst, &rdata);

    // Get entry point and clean up decryption buffer
    DLLMAIN_FUNC entryPoint = (DLLMAIN_FUNC)EntryPoint(&data, dst);
    KERNEL32$VirtualFree(src, 0, MEM_RELEASE);

    // Two DllMain calls (no USER_DATA needed)
    entryPoint((HINSTANCE)dst, DLL_PROCESS_ATTACH, &rdata);               // pass rdata info
    entryPoint((HINSTANCE)GETRESOURCE(go), 0x04, loaderArguments);  // start with loader args
}</code></pre>

<p>Each phase of this function maps directly to a stage in the loading process:</p>

<div class="card">
<h4>Phase-by-Phase Breakdown</h4>
<table>
<thead>
<tr><th>Phase</th><th>Lines</th><th>What Happens</th></tr>
</thead>
<tbody>
<tr><td><strong>Resource Retrieval</strong></td><td><code>GETRESOURCE</code></td><td>The <code>_DLL_</code> and <code>_KEY_</code> macros resolve to named sections that Crystal Palace linked into the PIC blob. <code>GETRESOURCE</code> uses RIP-relative addressing to locate them.</td></tr>
<tr><td><strong>XOR Decryption</strong></td><td><code>VirtualAlloc</code> + XOR loop</td><td>Allocates a RW buffer (<code>src</code>) and decrypts the postex DLL using a rolling XOR with the 128-byte key. The decrypted buffer is a raw PE file.</td></tr>
<tr><td><strong>PE Parsing</strong></td><td><code>ParseDLL</code></td><td>LibTCG parses the PE headers, section table, import directory, and relocation table into a <code>DLLDATA</code> structure.</td></tr>
<tr><td><strong>Section Loading</strong></td><td><code>LoadDLL</code></td><td>Allocates the final image region (RW) and copies each PE section to its correct virtual address offset.</td></tr>
<tr><td><strong>Import Resolution</strong></td><td><code>ProcessImports</code></td><td>Takes an <code>IMPORTFUNCS</code> struct, the <code>DLLDATA</code>, and <code>dst</code>. Walks the import directory and resolves each function using the DFR-rewritten <code>resolve()</code>, which delegates to the patched <code>$GMH</code>/<code>$GPA</code>.</td></tr>
<tr><td><strong>Permission Fixing</strong></td><td><code>FixSectionPermissions</code></td><td>Sets correct page protections for each section (<code>.text</code> to RX, <code>.rdata</code> to R, <code>.data</code> to RW). Captures <code>.rdata</code> boundaries into the <code>RDATA_SECTION</code> struct.</td></tr>
<tr><td><strong>Cleanup</strong></td><td><code>VirtualFree</code></td><td>Releases the temporary decryption buffer (<code>src</code>). The encrypted DLL data and XOR key are no longer needed.</td></tr>
<tr><td><strong>DllMain #1</strong></td><td><code>DLL_PROCESS_ATTACH</code></td><td>Calls the postex DLL's entry point with <code>(HINSTANCE)dst</code> and <code>&amp;rdata</code> as the reserved parameter, giving it the information needed for .rdata obfuscation.</td></tr>
<tr><td><strong>DllMain #2</strong></td><td><code>0x04</code></td><td>Calls DllMain again with reason <code>0x04</code>, passing <code>(HINSTANCE)GETRESOURCE(go)</code> as the module handle and <code>loaderArguments</code> from the parent Beacon, starting the actual postex operation (mimikatz dump, screenshot capture, etc.).</td></tr>
</tbody>
</table>
</div>

<h3>Contrast with Beacon UDRL go()</h3>

<p>The Beacon UDRL's <code>go()</code> function makes <strong>three</strong> DllMain calls:</p>

<div class="card">
<h4>Beacon UDRL: Three DllMain Calls</h4>
<ol>
<li><code>entryPoint((HINSTANCE)0, DLL_BEACON_USER_DATA, &amp;bud)</code> &mdash; passes the <code>BEACON_USER_DATA</code> structure using the special <code>DLL_BEACON_USER_DATA</code> reason code and <code>(HINSTANCE)0</code> as the module handle</li>
<li><code>entryPoint((HINSTANCE)dst, DLL_PROCESS_ATTACH, NULL)</code> &mdash; standard DLL initialization with the actual loaded image base</li>
<li><code>entryPoint((HINSTANCE)GETRESOURCE(go), DLL_BEACON_START, NULL)</code> &mdash; starts the Beacon main loop</li>
</ol>
<p>The postex loader skips the first call entirely because there is no <code>BEACON_USER_DATA</code> to pass. Postex DLLs do not need syscall stubs or memory region tracking &mdash; they operate within the context of an already-running Beacon that handles those concerns.</p>
</div>

<!-- ============================================================ -->
<h2>7. The Aggressor Script (crystalpalace.cna)</h2>

<p>The Aggressor script is the glue that connects Crystal Palace to Cobalt Strike's runtime. It implements the hooks that Cobalt Strike calls when it needs to generate loader payloads, passing the appropriate parameters to the Crystal Palace linker.</p>

<pre><code><span class="lang-tag">Java/Sleep (crystalpalace.cna)</span>import crystalpalace.spec.* from: crystalpalace.jar;
import java.util.HashMap;

set BEACON_RDLL_GENERATE {
    local('$spec $spec_path $result');

    // $1 = filename, $2 = beacon DLL bytes, $3 = arch
    if ($3 eq "x86") { return $null; }  // x64 only

    $spec_path = getFileProper(script_resource("udrl"), "loader.spec");
    $spec = [LinkSpec Parse: $spec_path];
    $result = [$spec run: $2, new HashMap];

    if (strlen($result) == 0) {
        warn("Crystal Palace: BEACON_RDLL_GENERATE failed");
        return $null;
    }

    return $result;
}

set BEACON_RDLL_SIZE {
    return "0";  // dynamic size
}

set POSTEX_RDLL_GENERATE {
    local('$spec $spec_path $hashMap $result');

    // $1 = filename, $2 = postex DLL bytes, $3 = arch
    // $4 = beacon ID, $5 = $GMH, $6 = $GPA
    if ($3 eq "x86") { return $null; }

    $spec_path = getFileProper(script_resource("postex-udrl"), "loader.spec");
    $spec = [LinkSpec Parse: $spec_path];
    $hashMap = new HashMap;
    [$hashMap put: "\$GMH", cast($5, 'b')];
    [$hashMap put: "\$GPA", cast($6, 'b')];

    $result = [$spec run: $2, $hashMap];

    if (strlen($result) == 0) {
        warn("Crystal Palace: POSTEX_RDLL_GENERATE failed");
        return $null;
    }

    return $result;
}</code></pre>

<p>The three hooks each serve a distinct purpose in the payload generation pipeline. Note that in Cobalt Strike's Sleep language, the <code>set</code> keyword assigns named hook callbacks (such as RDLL hooks), while <code>on</code> registers event handlers &mdash; these are different mechanisms. The <code>import java.util.HashMap</code> at the top makes the Java HashMap class available for passing patch variables.</p>

<h3>BEACON_RDLL_GENERATE</h3>

<div class="card">
<h4>Hook: BEACON_RDLL_GENERATE</h4>
<p><strong>When it fires:</strong> Every time Cobalt Strike generates a Beacon payload (HTTP listener, HTTPS listener, SMB pipe, etc.).</p>
<p><strong>Parameters received:</strong></p>
<ul>
<li><code>$1</code> &mdash; The filename hint (e.g., <code>"beacon.dll"</code>)</li>
<li><code>$2</code> &mdash; The raw Beacon DLL bytes (the PE file that needs to be loaded)</li>
<li><code>$3</code> &mdash; The architecture string (<code>"x86"</code> or <code>"x64"</code>)</li>
</ul>
<p><strong>What it does:</strong> Uses <code>getFileProper</code> to construct the spec file path and calls <code>LinkSpec Parse</code> to load the Beacon UDRL spec. Feeds it the Beacon DLL bytes (which become <code>$DLL</code> in the spec) and returns the complete PIC payload. The <code>new HashMap</code> is empty because the Beacon spec has no external variables to patch. Includes error handling: if the result has <code>strlen() == 0</code>, a <code>warn()</code> fallback fires and <code>$null</code> is returned.</p>
<p><strong>Return value:</strong> The final PIC shellcode blob, or <code>$null</code> if the architecture is x86 (Crystal-Loaders is x64-only) or if Crystal Palace fails.</p>
</div>

<h3>BEACON_RDLL_SIZE</h3>

<div class="card">
<h4>Hook: BEACON_RDLL_SIZE</h4>
<p><strong>When it fires:</strong> Before <code>BEACON_RDLL_GENERATE</code>, to determine how much space to reserve for the loader.</p>
<p><strong>Return value:</strong> <code>"0"</code> indicates the loader size is <strong>dynamic</strong>. Crystal Palace determines the exact size at link time based on the code, libraries, and encrypted payload. Returning <code>"0"</code> tells Cobalt Strike not to pre-allocate a fixed buffer but to accept whatever size Crystal Palace produces.</p>
</div>

<h3>POSTEX_RDLL_GENERATE</h3>

<div class="card">
<h4>Hook: POSTEX_RDLL_GENERATE</h4>
<p><strong>When it fires:</strong> Every time an operator runs a postex command (<code>mimikatz</code>, <code>screenshot</code>, <code>keylogger</code>, etc.) that requires loading a DLL into the Beacon process.</p>
<p><strong>Parameters received:</strong></p>
<ul>
<li><code>$1</code> &mdash; The filename hint (e.g., <code>"mimikatz.dll"</code>)</li>
<li><code>$2</code> &mdash; The raw postex DLL bytes</li>
<li><code>$3</code> &mdash; The architecture string</li>
<li><code>$4</code> &mdash; The parent Beacon's ID (integer)</li>
<li><code>$5</code> &mdash; The parent Beacon's <code>GetModuleHandleA</code> address (<code>$GMH</code>)</li>
<li><code>$6</code> &mdash; The parent Beacon's <code>GetProcAddress</code> address (<code>$GPA</code>)</li>
</ul>
<p><strong>What it does:</strong> Uses <code>getFileProper</code> to construct the spec file path and calls <code>LinkSpec Parse</code> to load the postex spec. Constructs a <code>HashMap</code> containing <code>$GMH</code> and <code>$GPA</code> as byte arrays (via <code>cast($5, 'b')</code>), and passes both the DLL bytes and the hash map to Crystal Palace. The <code>patch</code> directives in the spec resolve <code>$GMH</code> and <code>$GPA</code> from this hash map. Includes error handling: if the result has <code>strlen() == 0</code>, a <code>warn()</code> fallback fires and <code>$null</code> is returned.</p>
<p><strong>Return value:</strong> The complete postex PIC payload with patched-in function pointers, or <code>$null</code> on failure.</p>
</div>

<div class="card highlight">
<h4>The HashMap is the Bridge</h4>
<p>The key insight is how data flows from Cobalt Strike through Aggressor into Crystal Palace. The <code>$GMH</code> and <code>$GPA</code> values originate from the running Beacon on the target machine. Cobalt Strike resolves them from Beacon's process context, passes them as parameters to the Aggressor hook, and the script packages them into a <code>HashMap</code> that Crystal Palace reads when processing <code>patch</code> directives. By the time the PIC blob is assembled, the correct function addresses are baked directly into the shellcode's <code>.text</code> section.</p>
</div>

<!-- ============================================================ -->
<h2>8. The Full Build Pipeline</h2>

<p>From writing C source code to a running Beacon on target, the Crystal-Loaders system involves eight distinct stages. The following diagram traces the complete pipeline:</p>

<div class="diagram">
<h4 style="color:var(--accent);text-align:center;margin-bottom:15px;">Complete Crystal-Loaders Build Pipeline</h4>
<div class="flow" style="flex-direction:column;gap:4px">
<div class="box" style="width:100%"><strong>1. Write C Loader</strong> &mdash; Author <code>loader.c</code> with <code>go()</code> entry point, <code>resolve()</code> function, and PE loading logic using LibTCG primitives.</div>
<div class="box" style="width:100%"><strong>2. Compile with MinGW</strong> &mdash; <code>x86_64-w64-mingw32-gcc -c loader.c -o bin/loader.x64.o</code> produces a COFF object file. The <code>-c</code> flag stops before linking.</div>
<div class="box" style="width:100%"><strong>3. Write Spec File</strong> &mdash; Author <code>loader.spec</code> defining the PIC transformation, DFR method, library merges, payload encryption, and data linking.</div>
<div class="box hl" style="width:100%"><strong>4. CS Triggers Hook</strong> &mdash; At runtime, Cobalt Strike fires <code>BEACON_RDLL_GENERATE</code> (or <code>POSTEX_RDLL_GENERATE</code>), passing the raw DLL bytes and architecture info to the Aggressor script.</div>
<div class="box hl" style="width:100%"><strong>5. Aggressor Loads Spec</strong> &mdash; The <code>.cna</code> script calls <code>LinkSpec Parse</code> to load and parse the spec file, preparing the Crystal Palace linker engine.</div>
<div class="box" style="width:100%"><strong>6. Crystal Palace Executes</strong> &mdash; The linker performs six sub-operations:</div>
</div>
</div>

<div class="card">
<h4>Crystal Palace Sub-Operations (Step 6)</h4>
<table>
<thead>
<tr><th>Sub-Step</th><th>Operation</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td>6a</td><td>Load <code>loader.x64.o</code></td><td>COFF object loaded into linker memory</td></tr>
<tr><td>6b</td><td><code>make pic +gofirst +optimize +disco</code></td><td>COFF transformed to PIC with <code>go()</code> at offset 0</td></tr>
<tr><td>6c</td><td><code>dfr "resolve" "ror13"</code> (or <code>"strings"</code>)</td><td>All DLL import references rewritten to call <code>resolve()</code></td></tr>
<tr><td>6d</td><td><code>mergelib</code> LibGate + LibTCG (or LibTCG only)</td><td>Library code merged into the PIC blob</td></tr>
<tr><td>6e</td><td><code>generate $KEY 128</code></td><td>128-byte random XOR key created</td></tr>
<tr><td>6f</td><td><code>push $DLL</code> / <code>xor</code> / <code>preplen</code> / <code>link</code></td><td>DLL XOR-encrypted, length-prefixed, linked as named section</td></tr>
</tbody>
</table>
</div>

<div class="diagram">
<div class="flow" style="flex-direction:column;gap:4px">
<div class="box g" style="width:100%"><strong>7. CS Wraps PIC Blob</strong> &mdash; Cobalt Strike takes the exported PIC blob and wraps it into the appropriate delivery mechanism (stager shellcode, staged payload, or raw artifact).</div>
<div class="box g" style="width:100%"><strong>8. Execution on Target</strong> &mdash; The stager delivers the PIC blob to the target process. Execution begins at byte 0 (<code>go()</code>). The loader decrypts the embedded DLL, loads it via LibTCG, resolves imports via DFR, and calls <code>DllMain</code> to start Beacon.</div>
</div>
</div>

<div class="card green">
<h4>Pipeline Summary</h4>
<p>The pipeline transforms human-readable C code into a flat, encrypted, position-independent shellcode blob that loads a full-featured DLL implant from memory. At no point in this pipeline does a traditional PE file exist in the target process's memory. The DLL is encrypted inside the PIC blob, decrypted into a temporary buffer, loaded section-by-section into a final allocation, and the temporary buffer is freed. The only persistent artifacts are the PIC code itself (which has no PE headers) and the loaded DLL sections (which have correct per-section permissions instead of a single RWX blob).</p>
</div>

<!-- ============================================================ -->
<div class="quiz" id="quiz7">
<h4>Module 7 Knowledge Check</h4>

<div class="quiz-q" data-correct="1">
<p>Q1: How does the postex loader resolve Windows API functions?</p>
<label data-opt="0"><input type="radio" name="q7_0"> PEB walking with ROR13 hashes</label>
<label data-opt="1"><input type="radio" name="q7_0"> Using $GMH and $GPA function pointers patched by Crystal Palace</label>
<label data-opt="2"><input type="radio" name="q7_0"> Direct syscalls via LibGate</label>
<label data-opt="3"><input type="radio" name="q7_0"> Static P/Invoke imports</label>
<div class="explain">The postex loader declares global function pointers (<code>pGetModuleHandle</code> and <code>pGetProcAddress</code>) in the <code>.text</code> section. Crystal Palace's <code>patch</code> directive writes the parent Beacon's <code>GetModuleHandleA</code> (<code>$GMH</code>) and <code>GetProcAddress</code> (<code>$GPA</code>) addresses into these locations at link time. The postex <code>resolve()</code> function then uses these patched pointers to resolve all API imports. No PEB walking or syscalls are needed.</div>
</div>

<div class="quiz-q" data-correct="0">
<p>Q2: What Aggressor hook handles Beacon UDRL generation?</p>
<label data-opt="0"><input type="radio" name="q7_1"> BEACON_RDLL_GENERATE</label>
<label data-opt="1"><input type="radio" name="q7_1"> POSTEX_RDLL_GENERATE</label>
<label data-opt="2"><input type="radio" name="q7_1"> BEACON_RDLL_SIZE</label>
<label data-opt="3"><input type="radio" name="q7_1"> ARTIFACT_GENERATE</label>
<div class="explain"><code>BEACON_RDLL_GENERATE</code> fires every time Cobalt Strike generates a Beacon payload. It receives the raw Beacon DLL bytes, architecture string, and filename hint. The Aggressor script loads the Beacon UDRL spec file and returns the Crystal Palace PIC output. <code>POSTEX_RDLL_GENERATE</code> handles postex DLL loading, <code>BEACON_RDLL_SIZE</code> reports the loader size, and <code>ARTIFACT_GENERATE</code> is a different hook for artifact packaging.</div>
</div>

<div class="quiz-q" data-correct="2">
<p>Q3: Why does the postex loader track RDATA_SECTION instead of full ALLOCATED_MEMORY?</p>
<label data-opt="0"><input type="radio" name="q7_2"> It doesn't need memory tracking at all</label>
<label data-opt="1"><input type="radio" name="q7_2"> The parent Beacon already tracks all memory</label>
<label data-opt="2"><input type="radio" name="q7_2"> Long-running postex DLLs need to obfuscate .rdata (containing the IAT) while idle</label>
<label data-opt="3"><input type="radio" name="q7_2"> Crystal Palace doesn't support ALLOCATED_MEMORY for postex</label>
<div class="explain">Long-running postex DLLs like keyloggers and screenshot loops persist in memory for extended periods. Their <code>.rdata</code> section contains the resolved Import Address Table (IAT), which holds function pointers that memory scanners can identify as evidence of a loaded PE. By tracking the <code>.rdata</code> section's start address, size, and IAT offset via the <code>RDATA_SECTION</code> structure, the postex DLL can XOR-encrypt its own <code>.rdata</code> while idle and decrypt it only when actively executing, similar to how the Beacon's sleep mask protects its own memory.</div>
</div>

<button class="quiz-btn" onclick="gradeQuiz('quiz7')">Check Answers</button>
<div class="quiz-result"></div>
</div>

<div class="nav-btns">
<a href="module6.html">&larr; Prev: Beacon User Data</a>
<a class="primary" href="module8.html">Next: Extending Loaders &rarr;</a>
</div>
</main>

<script src="../../../assets/course.js"></script>
</body>
</html>